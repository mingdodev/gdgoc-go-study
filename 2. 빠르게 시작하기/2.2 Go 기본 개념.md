# 2.2.1 일반적인 프로젝트 구조

- 엄격한 프로젝트 구조를 요구하지는 않으나, 다음과 같은 [표준](https://github.com/golang-standards/project-layout)이 존재한다.

- ~~단일 소스코드 파일의 파일명이 패키지 이름이 되며~~, **파일의 첫 번째 줄에 `package -`라는 구문이 선언**된다.

> 이건 main.go에만 해당되는 말 아닌가? main은 프로그램의 entry이므로 실행가능한 파일임을 알려줘야 하기 때문에.

- 일반적으로는 파일이 속한 디렉터리 이름이 패키지 이름이 되는 게 관례이다. 단, 달라지는 것도 가능.

## 디렉터리 구조

- `/vendor`

    - 프로젝트의 종속성 저장
    - `go mod vendor` 명령어를 통해 자동 생성

- `/internal`

    - API로 호출되어 사용되지 않는 부분
    - 서로 다른 모듈 내에서 다수의 인터널 디렉터리가 존재할 수 있음

- `go.mod`

    - 프로젝트 최상위에 위치하는 고 모듈 파일
    - 패키지에서 동일하게 유지되는 정보를 저장: 패키지가 포함된 모듈의 이름, 컴파일한 go 버전, 코드 종속성

- `go.sum`

    - 특정 모듈 버전의 콘텐츠 관련 암호화 해시 정보
    - 종속성 손상 및 예상하지 못한 콘텐츠를 감지

## 예약된 토큰

- 많은 프로그래밍 언어에서 볼 수 있는 예약어 이외에도 `chan, type, go, defer, fallthrough, map 등`이 존재

<br>

---

# 2.2.2 Go의 시작

```go

package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}

```

<br>

---

# 2.2.3 변수

- Go는 강 타입이면서 정적 타입 언어

    - 컴파일러가 **변수의 타입을 자동으로 변환하지 않는다**. 명시적 형변환(비트 수준에서도)이 필요하다.
    - 변수 선언 시 타입 선언이나 초기값이 필요하다.

## 전역 정적 변수

전역 정적 변수를 선언해보자.

### 초기화 + 선언

```go
var age = 16
```

초기와와 선언이 함께 작동하여, 변수를 int 타입으로 표시한다. 

### 초기화 없이 선언

```go
var age int
```
변수 타입에 해당하는 코드를 명시적으로 작성해야 한다.

#### cf. 접근 제어

접근 제어를 위해 별도의 정보를 추가하지 않고, 첫 글자의 대소문자로 public, private 여부를 결정한다. (대문자 카멜 표기법)

- 대문자: public
- 소문자: private

### 변수 여러 개를 한 번에 초기화

```go
var (
    name = "Cat"
    age = 16
)
```

두 문자열을 전역 변수로 선언, 초기화할 수 있다. 서로 다른 타입도 가능.

#### cf. 코드라인 끝에 콤마가 없는 이유?

값의 할당 자체가 변수 간 구분자 역할을 하기 때문이다.

## 전역 상수

수정이 불가능한 상수에 대해 알아보자.

안전성을 중시하는 고는 상수의 포인터를 직접 가져와 수정하는 것을 금지한다. 이러한 규칙을 통해 컴파일러가 일부 계산을 컴파일 단계에서 미리 수행하는 **상수 폴딩**과 같은 최적화 작업이 가능해진다!

```go
const name1 = "Cat"
const name2 string = "Dog"
```

- 전역 상수는 값의 변경이 불가능하므로, **초기화 없이 선언만 하는 것은 불가능**하다.
- map 타입(가변성을 가짐)은 상수로 사용할 수 없다. 전역 정적 변수를 이용해야 한다.

## 지역 변수

```go
package main
import (
    "fmt"
)

func main() {
    name := "Anna"
    fmt.Println(name)

    var age int
    age = 26
    fmt.Println(age)
}
```

- name이라는 변수를 만들고 그 안에 문자열 "Anna"를 저장해
- 코드 구간이 끝나면 값이 삭제되며, 다른 변수에 의한 참조가 있다면 해당 참조도 가비지 컬렉터가 삭제한다.

> **:=** 는 var 키워드 없이 변수를 선언하며, 초기화 값을 통해 타입을 추론하고, 값 할당까지 담당한다.

## 지역 상수

```go
func main() {
    const pi float32 = 3.14159
}
```

## 변수 타입

- string
- int8/int16/int32/int64
- uint8/uint16/uint32/uint64
- uint/int: 시스템 bit에 따라 32 or 64
- float32/float64: 부동 소수점 타입

## 배열

- []T: 배열. (e.g. []string)
- 연속적인 메모리 블록으로 저장됨. 첫 요소에 대한 포인터로 나머지 요소에 접근 가능.

```go
names := []string{"cat", "dog"}

var ages []int
ages = []int{1, 2, 3}
```

### append

```go
names = append(names, "fox")
```

append 함수는 배열의 마지막 부분에 새로운 요소를 위한 메모리를 할당하고, 두 번째 인자로 전달된 값을 해당 영역에 설정한다. 그런 다음 새롭게 구성된 배열을 반환한다.

> **포인터로 접근하는 것 같은데, 왜 `names =`로 할당하는 과정이 필요한가?**  
> go에서도 배열의 크기가 불변이기 때문이다.  append 함수는 배열의 주소, 길이, 용량 정보를 반환한다. 만약 요소 추가 시 용량이 부족하다면 완전히 새로운 버퍼를 할당하고 기존 요소들을 복사하는 '재할당'이 일어나므로, 이 정보들이 완전히 바뀌어야 한다. 또한 용량이 부족하지 않다고 해도, 길이 정보가 변경되기 때문에, append 함수의 반환 값을 기존 변수에 할당해주어야 한다!!

<br>

### make
미리 요소의 개수를 알고 있다면, 재할당 없이 효율적으로 배열에 요소를 할당할 수 있다.

```go
names := make([]string, 3)
names[0] = "cat"
names[1] = "dog"
names[2] = "fox"
```

#### cf. Go의 Zero Value

최초 make 호출 시에도 '길이' 정보가 전달되어야 하기 때문에, 배열을 만든 뒤 값을 설정하지 않는다면 해당 영역에는 가비지 값이 들어가게 된다. 라고 했는데 실제로 코드를 돌려보니

```go
package main

import (
	"fmt"
)

func main() {
	names := make([]string, 3)
	names[0] = "cat"
	// names[1] = "dog"
	names[2] = "fox"

	fmt.Println(names[0])
    fmt.Println(names[1])
	fmt.Println(names[2])
}
```
에 대한 출력값으로

```
cat

fox
```
이 나왔다. 왜지? 하고 찾아보니

Go는 안정성을 지향하기 때문에 예측 가능함을 중요하게 생각한다. 따라서, 변수를 선언하고 초기화하지 않으면 해당 타입의 **제로 값**으로 자동 초기화가 된다고 한다.

- string: "" (빈 문자열)

- int, float, uint: 0

- bool: false

- 슬라이스, 맵, 포인터, 채널: nil

#### make 함수로 미리 메모리 버퍼 확보하기

```go
func main() {
	names := make([]string, 0, 3)
	fmt.Println(len(names))
    names = append(names, "Tanmay Bakshi")
    names = append(names, "Baheer Kamal")
    fmt.Println(len(names))
}
```
로 실행하면,

```
0
2
```
라는 출력을 얻을 수 있다.

두 번째 인자 0으로 비어있는 배열을 만들되, 세 번째 인자에 원하는 용량을 전달하면 미리 메모리 버퍼를 확보할 수 있다!

**용량이 확보되어 있지 않다면 새로운 요소를 추가할 때마다 매번 재할당이 필요할 것이다. 이러한 코드 구성으로 시간 절약 가능!**

```go
	names := make([]string, 0, 3)
	fmt.Println(len(names))
    fmt.Println(names[0])
```
참고로 용량만 확보되어 있을 뿐이지 실제 길이는 0 이므로 이런 코드는 index out of range 에러가 발생한다.

<br>

---

 # 2.2.4 if문 그리고 switch문

 ## if문

 ```go
 if (age >= 18) {
    ...
 } else if (age > 9) {
    ...
 } else {
    ...
 }
 ```

 ## switch문

```go
switch name {
case "Tanmay Bakshi":
    fmt.Println("Hi, Tanmay.")
case "Baheer Kamal":
    fmt.Println("Hi, Baheer.")
case "Michael":
    fmt.Println("Michael!")
default:
    fmt.Println("Sorry~ I don't know who you are.")
}
```

- case에 명시된 조건이 충족되지 않을 때 호출되는 default문을 반드시 작성해야 한다.
- 해당하는 case가 있다면 다음 case가 아닌 switch 코드 구간 다음 줄로 이동하므로, break는 필요 없다. _(자바와의 차이점! 자바는 break가 없고 default가 있으면 언제나 default값이 나온다.)_

<br>

---

# 2.2.5 반복문

<br>

---

# 2.2.6 함수

<br>

---

# 2.2.7 구조체