# 5.2 고루틴

## 고루틴이란?

- 함수를 호출할 수 있는 다양한 실행 스트림을 네이티브 스레드에 매핑하는 개념
- 고루틴: `2KB`
- 네이티브 스레드: `1MB` + `가드 페이지`

## 고루틴 문법과 동작 원리

```go
func main() {
    go squareIt(2)
}
```

- 함수 앞에 `go` 붙이기
- 고루틴으로 작업을 요청한 뒤 프로그램의 주도권이 즉시 반환되므로, 메인 스레드 및 메인 고루틴은 그대로 실행된다.
- 고루틴의 작업이 종료될 때까지 기다리려면 **채널**이 필요

- 고루틴도 특정 스레드에 고정시킬 수 있다.
- 고루틴에서 syscall로 인한 블로킹이 생기면, 고 런타임은 새로운 스레드를 만들어 얘를 매핑하여 다른 고루틴이 블로킹이 되지 않게 해준다. 이게 스레드 간 전환으로 이루어졌다면 모든 레지스터를  저장해야하지만 고루틴은 레지스터 3개만 저장하면 된다.
- 고루틴은 한 고루틴이 다른 고루틴을 직접 제어할 수 없다는 한계가 있다. 즉, 다른 고루틴을 강제로 종료하거나 병합할 수 없으며, 고루틴은 자신이 실행하는 함수가 끝나 반환될 때에만 종료된다.
- `go` 키워드는 반환값을 호출된 고루틴으로 전달하지 않는다. 이로 인해 고루틴으로 실행한 함수가 값을 직접 반환하지 못하는 문제가 발생할 수 있는데, 이러한 경우에는 채널을 활용하여 결과나 정보를 공유함으로써 문제를 해결한다.

```go
func add(a, b int, ch chan int) {
    ch <- a + b
}

func main() {
    ch := make(chan int)
    go add(2, 3, ch)
    result := <-ch
    fmt.Println(result) // 5
}
```