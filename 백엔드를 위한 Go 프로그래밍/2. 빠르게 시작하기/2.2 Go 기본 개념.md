# 2.2.1 일반적인 프로젝트 구조

- 엄격한 프로젝트 구조를 요구하지는 않으나, 다음과 같은 [표준](https://github.com/golang-standards/project-layout)이 존재한다.

- ~~단일 소스코드 파일의 파일명이 패키지 이름이 되며~~, **파일의 첫 번째 줄에 `package -`라는 구문이 선언**된다.

> 이건 main.go에만 해당되는 말 아닌가? main은 프로그램의 entry이므로 실행가능한 파일임을 알려줘야 하기 때문에.

- 일반적으로는 파일이 속한 디렉터리 이름이 패키지 이름이 되는 게 관례이다. 단, 달라지는 것도 가능.

## 디렉터리 구조

- `/vendor`

    - 프로젝트의 종속성 저장
    - `go mod vendor` 명령어를 통해 자동 생성

- `/internal`

    - API로 호출되어 사용되지 않는 부분
    - 서로 다른 모듈 내에서 다수의 인터널 디렉터리가 존재할 수 있음

- `go.mod`

    - 프로젝트 최상위에 위치하는 고 모듈 파일
    - 패키지에서 동일하게 유지되는 정보를 저장: 패키지가 포함된 모듈의 이름, 컴파일한 go 버전, 코드 종속성

- `go.sum`

    - 특정 모듈 버전의 콘텐츠 관련 암호화 해시 정보
    - 종속성 손상 및 예상하지 못한 콘텐츠를 감지

## 예약된 토큰

- 많은 프로그래밍 언어에서 볼 수 있는 예약어 이외에도 `chan, type, go, defer, fallthrough, map 등`이 존재

<br>

---

# 2.2.2 Go의 시작

```go

package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}

```

<br>

---

# 2.2.3 변수

- Go는 강 타입이면서 정적 타입 언어

    - 컴파일러가 **변수의 타입을 자동으로 변환하지 않는다**. 명시적 형변환(비트 수준에서도)이 필요하다.
    - 변수 선언 시 타입 선언이나 초기값이 필요하다.

## 전역 정적 변수

전역 정적 변수를 선언해보자.

### 초기화 + 선언

```go
var age = 16
```

초기와와 선언이 함께 작동하여, 변수를 int 타입으로 표시한다. 

### 초기화 없이 선언

```go
var age int
```
변수 타입에 해당하는 코드를 명시적으로 작성해야 한다.

#### cf. 접근 제어

접근 제어를 위해 별도의 정보를 추가하지 않고, 첫 글자의 대소문자로 public, private 여부를 결정한다. (대문자 카멜 표기법)

- 대문자: public
- 소문자: private

### 변수 여러 개를 한 번에 초기화

```go
var (
    name = "Cat"
    age = 16
)
```

두 문자열을 전역 변수로 선언, 초기화할 수 있다. 서로 다른 타입도 가능.

#### cf. 코드라인 끝에 콤마가 없는 이유?

값의 할당 자체가 변수 간 구분자 역할을 하기 때문이다.

## 전역 상수

수정이 불가능한 상수에 대해 알아보자.

안전성을 중시하는 고는 상수의 포인터를 직접 가져와 수정하는 것을 금지한다. 이러한 규칙을 통해 컴파일러가 일부 계산을 컴파일 단계에서 미리 수행하는 **상수 폴딩**과 같은 최적화 작업이 가능해진다!

```go
const name1 = "Cat"
const name2 string = "Dog"
```

- 전역 상수는 값의 변경이 불가능하므로, **초기화 없이 선언만 하는 것은 불가능**하다.
- map 타입(가변성을 가짐)은 상수로 사용할 수 없다. 전역 정적 변수를 이용해야 한다.

## 지역 변수

```go
package main
import (
    "fmt"
)

func main() {
    name := "Anna"
    fmt.Println(name)

    var age int
    age = 26
    fmt.Println(age)
}
```

- name이라는 변수를 만들고 그 안에 문자열 "Anna"를 저장해
- 코드 구간이 끝나면 값이 삭제되며, 다른 변수에 의한 참조가 있다면 해당 참조도 가비지 컬렉터가 삭제한다.

> **:=** 는 var 키워드 없이 변수를 선언하며, 초기화 값을 통해 타입을 추론하고, 값 할당까지 담당한다.

## 지역 상수

```go
func main() {
    const pi float32 = 3.14159
}
```

## 변수 타입

- string
- int8/int16/int32/int64
- uint8/uint16/uint32/uint64
- uint/int: 시스템 bit에 따라 32 or 64
- float32/float64: 부동 소수점 타입

## 배열

- []T: 배열. (e.g. []string)
- 연속적인 메모리 블록으로 저장됨. 첫 요소에 대한 포인터로 나머지 요소에 접근 가능.

```go
names := []string{"cat", "dog"}

var ages []int
ages = []int{1, 2, 3}
```

### append

```go
names = append(names, "fox")
```

append 함수는 배열의 마지막 부분에 새로운 요소를 위한 메모리를 할당하고, 두 번째 인자로 전달된 값을 해당 영역에 설정한다. 그런 다음 새롭게 구성된 배열을 반환한다.

> **포인터로 접근하는 것 같은데, 왜 `names =`로 할당하는 과정이 필요한가?**  
> go에서도 배열의 크기가 불변이기 때문이다.  append 함수는 배열의 주소, 길이, 용량 정보를 반환한다. 만약 요소 추가 시 용량이 부족하다면 완전히 새로운 버퍼를 할당하고 기존 요소들을 복사하는 '재할당'이 일어나므로, 이 정보들이 완전히 바뀌어야 한다. 또한 용량이 부족하지 않다고 해도, 길이 정보가 변경되기 때문에, append 함수의 반환 값을 기존 변수에 할당해주어야 한다!!

<br>

### make
미리 요소의 개수를 알고 있다면, 재할당 없이 효율적으로 배열에 요소를 할당할 수 있다.

```go
names := make([]string, 3)
names[0] = "cat"
names[1] = "dog"
names[2] = "fox"
```

#### cf. Go의 Zero Value

최초 make 호출 시에도 '길이' 정보가 전달되어야 하기 때문에, 배열을 만든 뒤 값을 설정하지 않는다면 해당 영역에는 가비지 값이 들어가게 된다. 라고 했는데 실제로 코드를 돌려보니

```go
package main

import (
	"fmt"
)

func main() {
	names := make([]string, 3)
	names[0] = "cat"
	// names[1] = "dog"
	names[2] = "fox"

	fmt.Println(names[0])
    fmt.Println(names[1])
	fmt.Println(names[2])
}
```
에 대한 출력값으로

```
cat

fox
```
이 나왔다. 왜지? 하고 찾아보니

Go는 안정성을 지향하기 때문에 예측 가능함을 중요하게 생각한다. 따라서, 변수를 선언하고 초기화하지 않으면 해당 타입의 **제로 값**으로 자동 초기화가 된다고 한다.

- string: "" (빈 문자열)

- int, float, uint: 0

- bool: false

- **슬라이스, 맵, 포인터, 채널: nil**

> 다른 타입은 nil을 값으로 가질 수 없다!

#### make 함수로 미리 메모리 버퍼 확보하기

```go
func main() {
	names := make([]string, 0, 3)
	fmt.Println(len(names))
    names = append(names, "Tanmay Bakshi")
    names = append(names, "Baheer Kamal")
    fmt.Println(len(names))
}
```
로 실행하면,

```
0
2
```
라는 출력을 얻을 수 있다.

두 번째 인자 0으로 비어있는 배열을 만들되, 세 번째 인자에 원하는 용량을 전달하면 미리 메모리 버퍼를 확보할 수 있다!

**용량이 확보되어 있지 않다면 새로운 요소를 추가할 때마다 매번 재할당이 필요할 것이다. 이러한 코드 구성으로 시간 절약 가능!**

```go
	names := make([]string, 0, 3)
	fmt.Println(len(names))
    fmt.Println(names[0])
```
참고로 용량만 확보되어 있을 뿐이지 실제 길이는 0 이므로 이런 코드는 index out of range 에러가 발생한다.

<br>

---

 # 2.2.4 if문 그리고 switch문

 ## if문

 ```go
 if (age >= 18) {
    ...
 } else if (age > 9) {
    ...
 } else {
    ...
 }
 ```

 ## switch문

```go
switch name {
case "Tanmay Bakshi":
    fmt.Println("Hi, Tanmay.")
case "Baheer Kamal":
    fmt.Println("Hi, Baheer.")
case "Michael":
    fmt.Println("Michael!")
default:
    fmt.Println("Sorry~ I don't know who you are.")
}
```

- case에 명시된 조건이 충족되지 않을 때 호출되는 default문을 반드시 작성해야 한다.
- 해당하는 case가 있다면 다음 case가 아닌 switch 코드 구간 다음 줄로 이동하므로, break는 필요 없다. _(자바와의 차이점! 자바는 break가 없고 default가 있으면 언제나 default값이 나온다.)_

<br>

---

# 2.2.5 반복문

Go는 통상 세 가지 종류를 가지는 반복문을 **for** 하나로 대체한다.

## for-in

```go
func main() {
	names := []string{"cat", "dog", "fox"}
	for i := range names {
		fmt.Println(i)
	}
}
```
이 코드의 출력 결과는

```go
0
1
2
```
이다. 각 요소의 값을 출력하려면

```go
func main() {
	names := []string{"cat", "dog", "fox"}
	for _, v := range names {
		fmt.Println(i)
		fmt.Println(v)
	}
}
```
다음과 같은 코드를 작성해야 한다.

> _는 어떤 값이 나오든 상관 없으니 이 부분을 사용할 필요는 없다는 뜻

<br>

Go는 효율을 중시하기에 다른 언어들의 표준과 상당히 다른 양상을 보인다. Go의 `range` 반복문은 각 반복에서 인덱스와 값을 자동으로 제공하므로, 프로그래머가 별도의 카운터를 직접 관리할 필요 없이 간결하고 효율적으로 코드를 작성할 수 있다. (컴파일러가 알고 있는 **오프셋에 대한 변수**에 프로그래머가 접근하는 방식이라고 이해할 수 있다.)

## C 스타일의 반복문

```go
func main() {
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }
}
```
- for 반복문
- 반복자, 반복 조건, 반복 과정(카운터)

```go
func main() {
    i := 1
    for i < 1000 {
        i += i
    }
    fmt.PrintLn(i)
}
```
- while 반복문과 비슷한 표현
- 반복문이 계속 진행하는지를 확인하는 조건문만

<br>

- for문은 추후 학습할 **채널**에서 필요하다.

<br>

---

# 2.2.6 함수

```go
func operateOnPi(multiplier uint, offset int) float32 {
	return (3.14159 - float32(offset)) * float32(multiplier)
}

func main() {
	tau := operateOnPi(2, 1)
}
```
- func 함수명(인자의 이름 타입) 반환값의 타입 { }
- 형변환은, 어떤 타입에 해당하도록 나열된 비트를 다른 타입으로 변경하는 데 필요한 특정 규격을 따르게 되어 있다. 예를 들어 float32는 IEEE 754 규격을 따라, 1비트는 부호, 8비트는 지수, 23비트는 가수로 메모리에 표시된다. 반면 정수는 가장 왼쪽의 부호 비트와 이진법으로 구성되어 있다. 따라서 정수값을 float32로 변환하는 것은 간단하지 않다. 반드시 **형변환**을 통해 **Go에게 명시적으로 알려야 한다!**

> Go의 이런 명확한 규칙이 간결함과 안정성을 만든다.

## 함수가 여러 개의 값을 반환하기

```go
func nameAndAge(uid int) (string, int) {
	switch uid {
	case 0:
		return "cat", 24
	case 1:
		return "dog", 25
	default:
		return "", -1
	}
}
func main() {
	userName, userAge := nameAndAge(0);
}
```
- 새로운 변수를 선언할 때는 `:=` 연산자를 반드시 사용해야 하지만, 모든 변수가 이미 선언된 상황이라면 반드시 `=` 연산자를 사용해야 한다.

```go
    // ok
	var userName string
	userName, userAge := nameAndAge(0);

	// ok
	var userName string
	var userAge int
	userName, userAge = nameAndAge(0)
```

### 필요없는 변수를 무시하고 싶다면

```go
func main() {
    _, userAge := nameAndAge(0)
    fmt.Println("User age:")
    fmt.Println(userAge)
}
```

- Go 컴파일러는 **선언한 변수가 사용되지 않으면 오류를 발생**시킨다. 따라서, 직접 무시하고 싶은 변수를 알려줘야 한다.
- **밑줄은 새로운 변수로 간주하지 않는다.**

## 함수에 다른 함수를 전달하기

다른 함수를 호출하는 함수가 필요하지만 컴파일 타임에는 아직 어떤 함수를 호출하는지 모른다면?

```go
func runMathOp(a int, b int, op func(int, int) int) int {
	return op(a, b)
}
func add(a int, b int) int { return a + b }
func sub(a int, b int) int { return a - b }
func mul(a int , b int) int { return a * b}
func div(a int, b int) int { return a / b }

func main() {
	a, b := 9, 6
	fmt.Println(runMathOp(a, b, add))
	fmt.Println(runMathOp(a, b, sub))
	fmt.Println(runMathOp(a, b, mul))
	fmt.Println(runMathOp(a, b, div))
}
```

- 함수 인자에 선언한 함수 시그니처가 일치하기만 하면 파라미터를 전달하는 것처럼 또 다른 함수를 전달할 수 있다.

> **어? 함수는 선언하고 사용하지 않아도 오류를 발생시키지 않네?**  
> 오류를 발생시키는 근본적인 이유가 컴파일 최적화이기 때문이다. 선언하고 사용하지 않은 함수는 빌드시 실행 파일에 포함되지 않는다. 즉 규제할 대상이 아니다. 만약 불필요한 코드 제거의 목적으로 오류를 발생시켜버린다면... 라이브러리를 개발하고 배포했을 때 사용하지 않는 함수들로 인해 대량 오류가 발생할 것이다.

## defer

```go
func test(x int) int {
	defer fmt.Println(x)
	y := x + 1
	fmt.Println(y)
	return y
}

func main() {
	test(5)
}
```

- 함수를 반환하기 전에 어떤 코드를 실행하라고 명령한다.
- defer `호출되어야 하는 함수` 형태로 작성한다.
- defer는 해당 라인을 읽고 바로 실행되어 인자가 메모리에 저장되는 등의 일이 수행된다. 그러나 **코드는 실제 반환이 이루어지기 직전에 실행**된다.

<br>

```go
defer func() {
    fmt.Println("inline function")
}()
```
- defer에 함수를 인라인으로 정의하고 호출할 수도 있다.

## 제네릭

Go 1.18 이후 버전부터는 [제네릭](https://go.dev/doc/tutorial/generics) 문법을 지원한다.

```go
func SumInts(m map[string]int64) int64 {
	var s int64
	for _, v := range m {
		s += v
	}
	return s
}

func SumFloats(m map[string]float64) float64 {
	var s float64
	for _, v := range m {
		s += v
	}
	return s
}
```
제네릭이 없다면, 타입은 다르지만 로직은 똑같은 코드들을 반복 작성하거나 interface를 통해 복잡한 로직을 작성해야 한다.

```go
func SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {
	var s V
	for _, v := range m {
		s += v
	}
	return s
}
```
제너릭은 특정 타입에 종속되지 않은 일반화된 함수를 만들 수 있게 해준다.

- 함수 이름 뒤에 `[]` 대괄호를 선언하여, 타입 매개변수와 제약을 나타낸다.
- `[K comparable, V int64 | float64]`: K는 comparable 인터페이스를 만족해야 하며, V는 int64 또는 float64 타입 중 하나여야 한다.


<br>

---

# 2.2.7 구조체

Go는 객체 지향 프로그래밍 언어가 아니다. 클래스나 객체의 개념이 없고, 모든 것을 값으로 간주한다.  
따라서 Go는 관련 데이터를 저장하기 위해 구조체의 개념을 사용한다.

```go
type User struct {
	Name string
	Age  int
}

func nameAndAge(uid int) User {
	switch uid {
	case 0:
		return User{"Baheer", 24}
	case 1:
		return User{"Tanmay", 25}
	default:
		return User{"Unknown", -1}
	}
}

func main() {
	user := nameAndAge(0)
	fmt.Println("User age: ")
	fmt.Println(user.Age)
}
```

- 구조체는 데이터들을 연속적인 메모리 블록에 저장한다.

```go
func incrementAge(user *User) {
	user.Age++
	fmt.Println(user.Age)
}

func main() {
	kate := User{"kate", 25}
	incrementAge(&kate)
	fmt.Println(user.Age)
}
```
- 구조체는 값이기 때문에, 함수를 통해 관련 값을 수정하려면 해당 함수에 참조를 전달해야 한다.
- 단, **이것은 포인터가 아니다**. Go에서 처리하는 참조이다. 따라서 age에 접근하기 위해 함수 내에서 포인터를 역참조(`user->age`)할 필요가 없다.

> 왜 C++이나 Rust랑 Go를 비교하는지 알겠다

### 구조체에 함수 할당하기

```go
func (user User) prettyString() string {
	return fmt.Sprintf("%s is %d years old!", user.Name, user.Age)
}

func main() {
	...
	fmt.Println(kate.prettyString())
}
```
- 특정 구조체 위에 인스턴스 메서드를 만든다.

> 객체지향의 개념이었다면 객체 내부에 메서드를 만들었겠지만, go에서는 구조체를 매개로 관련 있는 데이터를 다룰 수 있는 듯

```go
func (user *User) incrementAge() {
	user.Age++
	fmt.Println(user.Age)
}

func main() {
	kate := User{"kate", 25}
	kate.incrementAge()
	fmt.Println(user.Age)
}
```

- 구조체 내부 값이 변경되어야 하는 경우에는 **포인터 리시버**를 사용한다.

> **값 리시버**는 구조체를 복사해서 사용한다. 내부 값이 변경되면 안 되는 읽기 작업 등에서 사용

<br>

---

# 2.2.8 인터페이스

```go
type Living interface {
	incrementAge()
	getAge() int
}

func incrementAndPrintAge(being Living) {
	being.incrementAge()
	fmt.Println(being.getAge())
}
```

- go의 인터페이스는 **암묵적 구현**을 지원한다. 만약 어떤 구조체가 특정 인터페이스가 요구하는 함수들을 구현했다면, 해당 구조체는 명시적인 선언 없이도 그 인터페이스 타입으로 취급될 수 있다.

> Java같은 경우 인터페이스를 구현하려면 명시적으로 `implements` 키워드가 필요하다.

```go
type Person struct {
	Name string
	Age  int
}

type Dog struct {
	Name  string
	Owner *Person
	Age   int
}

func (person *Person) incrementAge() {
	person.Age++
}

func (person *Person) getAge() int {
	return person.Age
}

func (dog *Dog) incrementAge() {
	dog.Age++
}

func (dog *Dog) getAge() int {
	return dog.Age
}

type Living interface {
	incrementAge()
	getAge() int
}

func incrementAndPrintAge(being Living) {
	being.incrementAge()
	fmt.Println(being.getAge())
}

func main() {
	kate := Person{"kate", 19}
	mong := Dog{"mong", &kate, 3}

	incrementAndPrintAge(&kate)
	incrementAndPrintAge(&mong)
}
```

코드를 찬찬히 읽어보고 잘못된 예시는 `interface-implements-error.go`, `interface-implements-ok.go`에서 확인할 것

<br>

---

# 2.2.9 오류

- 함수가 오류를 던지고 호출자가 잡는 방식을 권장하지 않고, error라는 타입을 반환하는 것을 권장한다.
- 실제 오류의 형태는 복잡하기 때문에, 사용자가 오류 구조체를 직접 정의할 수 있는 구조를 채택했다.
- 새로운 종류의 오류는 전역 변수로 정의한다.

```go
// 커스텀 오류 구조체 정의
type CustomError struct {
    Code    int
    Message string
}

// error 인터페이스의 Error() 메서드 구현
func (e *CustomError) Error() string {
    return fmt.Sprintf("Error Code %d: %s", e.Code, e.Message)
}

// 커스텀 오류를 반환하는 함수
func process(id int) error {
    if id < 0 {
        return &CustomError{Code: 400, Message: "invalid ID"}
    }
    return nil
}
```
- 이런 식으로 애플리케이션 요구 사항에 맞게 커스텀 오류를 정의하고 사용할 수 있다.

```go
func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    // panic이 발생하면 defer가 호출되어 recover()가 실행됨
    panic("A fatal error occurred!")
    fmt.Println("This line is never reached.")
}
```
- go는 예기치 못한 오류를 만나면 `panic()`이 발생한다. panic이 발생하면 현재 함수의 실행을 즉시 중단하고 defer 함수를 실행한 후, 호출 스택을 거슬러 올라가며 panic을 전파한다. 결국 프로그램 전체가 종료되는 문제가 생길 수 있다.
- 이를 방지하기 위해 `recover()`를 사용한다. defer 함수 내에서만 호출이 가능하며, panic이 발생했을 때 recover()가 호출되면 panic의 값을 반환하고, 프로그램의 실행 흐름을 다시 정상으로 돌려놓는다.