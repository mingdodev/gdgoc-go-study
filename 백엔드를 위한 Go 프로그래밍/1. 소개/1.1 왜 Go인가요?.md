# 1.1.1 Go의 설계 목표는 무엇인가요?

> 실행 속도, 컴파일 속도, 의존성 관리, 동시성, 최적화

## 기존 기술의 한계

- 대규모 코드베이스에서 느린 컴파일러
- low level C++ 구현의 복잡함
- high level Java의 무거움

## Go의 설계 목표

- 대규모 코드베이스를 빠르게 처리하는 컴파일러
- 최적화로 빠르게 코드를 생성하는 컴파일러

## 목표 실현을 위한 Go의 특징

- **엄격한 문법**: 쓰지 않는 변수, 임포트는 경고가 아닌 오류
- **최적화**: Go의 최적화는 어셈블리 코드에서 이루어짐, 어셈블리는 중간 코드 없이 바이너리 형태로 생성됨
- 간략한 문법과 안정성

<br>

---

# 1.1.2 어디서 Go를 활용할 수 있을까요?

- 다양한 운영체제와 CPU 아키텍처

<br>

---

# 1.1.3 Go 컴파일러와 런타임

- Go의 컴파일러는 컴파일 속도가 매우 빠름: 높은 성능
- 메모리를 수동 관리하거나 포인터를 직접 다루지 않고 모든 것을 추상화: 높은 생산성

## 메모리 관리와 매우 특별한 가비지 컬렉터

메모리 관리 기법은 일반적으로 다음 4가지가 있다. 어떤 게 좋냐?  
'구현' 관점에서 적절한 기법을 택하는 게 가장 합리적이다.

**1. 관리하지 않기**

- C언어
- 프로그래머에게 자율성과 책임 부여

**2. 가비지 컬렉션**

- Java, kotlin, python, go, JavaScript 등
- 프로그램에서 앞으로 참조되지 않을 메모리 영역을 찾아 삭제하는 방식
- GC가 일어나는 동안 애플리케이션이 잠깐 중지되며, GC 시점 예측이 어려워 메모리 영역이 불확실성을 갖게 됨

**3. 자동 참조 카운트**

- Swift, Objective-C
- 새로운 객체를 생성할 때마다 레퍼런스 카운터를 함께 생성, 참조할 때마다 카운터가 증가하며 참조한 객체가 유효 범위에서 사라지면 카운터가 감소
- 카운터가 0이면 메모리가 해제됨
- 레퍼런스 사이클에서 메모리가 해제되지 않는 경우가 발생하므로, 약한 참조/미소유 참조로 해결

> 약한 참조/미소유 참조는 참조하는 동안 카운터가 증가하지 않게 만드는 방법으로, 순환 참조 문제를 방지한다. 즉 자동 참조 카운트는 객체의 생명 주기를 잘 이해하고 관리해야 할 듯

**4. 컴파일 타입 오너십**

- Rust
- 코드 컴파일 시 메모리를 할당하거나 해제해야 할 시기를 결정할 수 있도록 함
- 컴파일러가 메모리 오너십을 명확히 하기 위해 생기는 이런 제약사항으로 프로그래머의 코드 작성이 복잡해질 수 있음
- 시스템 프로그래밍 언어와 같이 안정성이 필요한 분야에 적합

Go는 가비지 컬렉션을 사용한다. Go의 백그라운드에서 메모리를 수거하고 점진적으로 힙 메모리를 처리하는 방식은, STW(지연 시간)를 크게 줄여 GC의 단점을 보완한다.

<br>

---

# 1.1.4 동시성

**1. 멀티프로세싱**

- 많은 코어를 효율적으로 동작시키는 건 어렵다.

> 시스템 호출, 메모리 접근 등 코어가 다른 작업을 기다려야 하는 상황에서 코어를 놀게 가만히 둬야 할까? 또한, 코어가 최대한 놀지 않도록 만드는 동시에 컨텍스트 스위칭 오버헤드도 고려해야 한다.

**2. 멀티스레딩**

- 자체적인 스택 포인터를 갖는, 프로세스의 일부. 커널을 통해 수없이 많이 실행될 수 있다.
- 그러나 스레드는 상대적으로 매우 무겁다. 수천 개의 운영체제 스레드 정도로 스케일이 커진다면 컨텍스트 스위칭 비용이 감당하기 어려울 정도!

> 예를 들어 44개의 CPU 스레드가 존재하는 22코어의 시스템에서는 "수천 개"의 운영체제 스레드가 생성될 수 있다.
> CPU 스레드: CPU 코어가 한 번에 처리할 수 있는 작업의 최소 단위. 1개의 코어가 논리적으로 2개의 CPU 스레드로 작동할 수 있다.
> 운영체제 스레드: 운영체제의 스케줄러에 의해 CPU에 할당되는, 프로그램의 실행 흐름

**3. 고루틴(Goroutines)**

- Go의 해결책
- 운영체제 수준의 스레드가 아닌, Go의 런타임에서 처리되는 초경량의 유사 스레드 실행 환경을 의미한다.
- 운영체제 스레드에 매핑된 다음 CPU 스레드에 추가로 매핑되므로 큰 성능 저하 없이 수백만 개의 고루틴이 실행될 수 있다.

> 고루틴이라는 애플리케이션이 관리하는 스레드가 있으니까 운영체제 스레드 개수 자체가 줄어든다. 따라서 운영체제의 스케쥴링 부담이 적어지며 컨텍스트 스위칭 오버헤드가 줄어든다.

---

<br>

그외에도 Go는...

- 쿠버네티스, 도커를 개발한 백엔드 언어이다.
- 고루틴을 통한 확장 가능성을 가진다.

등 크고 복잡한 서비스를 구동하는 **마이크로 서비스 설계에 적합한 언어**임을 알 수 있다.