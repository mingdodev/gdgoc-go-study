# 6.2 C 코드와 상호 호환하기

```c
#include <stdio.h>
int main() {
    printf("Hello, World!\n")
    return 0;
}
```
- Go에서 이 코드를 호출하려면

```c
#include <stdio.h>
void printHelloWorld() {
    printf("Hello, World!\n")
}
```
- 프로그램의 진입점을 go로 할 수 있도록 새로운 이름의 함수로 변경
- 따라서 이 코드는 main 함수가 없으므로 c 컴파일러로는 컴파일하거나 실행할 수 없다. 그러나

```
-shared -fPIC -o libhelloworld.so
```
- 해당 플래그로 컴파일(Clang or GCC 컴파일러)하면, 공유 라이브러리 포맷의 기계어로 컴파일된다. 그러나 Go에서 이 공유 라이브러리를 호출할 수는 없다.
- 따라서, cgo라는 go의 라이브러리를 통해 C코드와 헤더를 포함하는 Go 코드를 컴파일 할 수 있고, 컴파일된 C 코드와 헤더를 연결할 수 있다. 즉 C 원시 코드를 컴파일하여 실행가능한 형태의 최종 파일을 Go에서 생성할 수 있다.

```go
package main

// #include <stdio.h>
// void printHelloWorld() {
//     printf("Hello, World!\n")
// }
import "C"

func main() {
    C.printHelloWorld()
}
```
- 해당 코드를 컴파일하고 실행하면, Go에서 C로 문자열을 출력하는 실행 파일을 확인할 수 있다.
- 둘의 문자열을 표현하는 방식이 다른 문제, 메모리 해제 방식의 차이는 `C.CString, C.free(unsafe.Pointer(a))`와 같이 Go에서 처리해줄 수 있다.
- 주석에 추가한 코드를 원하는대로 컴파일하도록 C 컴파일러에게 지시할 수도 있다.
    - `cgo CFLAGS: -O0`: 코드를 최적화하지 말고 어셈블리 변환을 위한 다이렉트 코드를 가능한 많이 사용할 것