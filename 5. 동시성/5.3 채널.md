# 5.3 채널

- 채널을 통해 다른 고루틴에 데이터를 보낼 수 있다.

```go
func squareIt(inputChan, outputChan chan int) {
	for x := range inputChan {
		outputChan <- x * x
	}
}

func main() {
	inputChan := make(chan int)
	outputChan := make(chan int) // #1

	go squareIt(inputChan, outputChan)
	for i := 0; i < 5; i++ {
		inputChan <- i
	}
	for i := range outputChan { // #2
		fmt.Println(i)
	}
}
```
- 새로운 고루틴이 출력 채널의 결과를 가져가는 고루틴을 기다리고, 그 고루틴은 새로운 고루틴이 입력 채널에서 입력을 가져갈 때까지 대기한다. 데드락 발생

```go
outputChannel := make(chan int, 10)
```
- 버퍼링된 채널은 이 문제를 해결한다. make 함수에 버퍼 크기를 전달해 주면, 채널은 그만큼의 요소들을 버퍼/저장할 수 있다.

```go
for i := 0; i < 5; i ++ {
    fmt.Println(<- outputChannel)
}
```
- outputChan이 비어있다면 계속 데이터를 기다리게 되므로, main 고루틴이 블로킹된다. 따라서 필요한 반복만큼의 횟수를 지정해준다.

```go
func squareIt(inputChan, outputChan chan int) {
	for x := range inputChan {
		outputChan <- x * x
	}
}

func main() {
	inputChan := make(chan int)
	outputChan := make(chan int, 5)

	go squareIt(inputChan, outputChan)
	for i := 0; i < 5; i++ {
		inputChan <- i
	}
	for i := 0; i < 5; i ++ {
        fmt.Println(<- outputChannel)
    }
    close(inputChannel)
}
```
- close로 입력 채널을 닫아, 채널을 기다리는 고루틴의 블로킹을 해제한다.
- 입력 채널을 가진 squarIt에서는 데이터가 몇 개 들어와야 끝나는지 모르니까

## 동기화 채널과 비동기 채널

- **동기화 채널**

    - 버퍼링되지 않은 채널
    - 채널에 데이터를 보내는 고루틴(송신자)은 다른 고루틴(수신자)이 그 데이터를 즉시 가져갈 때까지 블로킹되어서 기다린다. 마찬가지로, 수신자도 송신자가 데이터를 보낼 때까지 기다립니다.

- **비동기 채널**

    - 버퍼가 있는 채널
    - 채널에 데이터를 보내는 고루틴(송신자)은 채널의 버퍼가 가득 찰 때까지는 기다리지 않고 계속해서 데이터를 보낼 수 있다. 송신자는 채널의 버퍼가 가득 찼을 때만 블로킹된다.

## 비어있는 채널로 세마포어 구현하기

```go
fun main() {
    semaphore := make(chan struct{})
    go func() {
        semaphore <- struct{}{} // 빈 구조체 정의 후 값 생성하는 문법
        fmt.Println("signalling")
    }()
    <- semaphore // 블로킹
    fmt.Println("exiting")
}
```
- 이 코드는 이진 세마포어처럼 동작하며, 고루틴 간 동기화를 구현한다.


- 채널은 기본적으로 원형 연결 리스트라고 하는 데이터 구조를 사용하며, 연결 리스트의 각 노드에는 데이터를 보낸 고루틴에 대한 정보와 데이터 자체에 대한 포인터가 포함되어 있다.

## select문

```go
func squarerCuber(sqInChan, sqOutChan, cuInChan, cuOutChan, exitChan chan int) {
    var squareX int
    var cubeX int
    for {
        select {
        case squareX = <-sqInChan:         // 1️⃣ sqInChan에서 값이 들어오면
            sqOutChan <- squareX * squareX //    제곱해서 sqOutChan에 보냄

        case cubeX = <-cuInChan:           // 2️⃣ cuInChan에서 값이 들어오면
            cuOutChan <- cubeX * cubeX * cubeX // 세제곱해서 cuOutChan에 보냄

        case <-exitChan:                   // 3️⃣ exitChan에서 신호가 오면
            return                         //    함수 종료 (이러면 close 안 해도 되겠네)
        }
    }
}
```
- select는 고루틴이 다양한 채널로부터 데이터를 기다릴 수 있게 해준다.
- 가장 먼저 값을 제공한는 채널로부터 데이터를 가져갈 수 있도록 해 준다.
- `default`를 사용하면 아무 채널도 준비되지 않았을 때 블로킹되지 않고 다른 작업도 수행할 수 있게 해준다. 취소/실패 처리할 때 사용하는데, 반드시 데이터를 받아야 한다면 사용하지 않고 대답을 기다리는 게 맞다.
    - 실무에서는 `case <- time.After(30 * time.Second):` 이런 식으로 타임아웃 처리할 수도 있음.

- 고루틴에서는 사용자가 스레드에게 스스로 언제 종료해야 하는지를 알려줘야 하는 책임이 있다!!

## 클로저의 변수 캡처

```go
func main() {
    for i := 0; i ‹ 10; i+ {
        go func(nonCapturedI int) {
            time.Sleep(1 * time.Millisecond)
            fmt.Println(nonCapturedI)
        }(i)
    }
    time.Sleep(100 * time.Millisecond)
}
```
- Go의 클로저는 **변수의 참조(reference)**를 캡처한다. 따라서 nonCapturedI로 변수의 복사본을 캡처하지 않으면, 10개의 고루틴에서 고루틴 생성 10번을 마친 후의 i에 접근하게 된다.

    - 일반적인 객체 지향 언어에서는 클로저나 함수 리터럴이 변수를 캡처할 때 해당하는 복사본이 주어진다.

    > 예를 들면 자바에서도 익명 함수 캡처는 복사본으로 이뤄진다. 그래서 불변인 final이나 effectively final(사실상 한 번만 할당된 값)인 지역 변수만 캡처한다.